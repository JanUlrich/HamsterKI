/*class*//**
 * HamsterWegfindung berechnet die Energieaufwände für einen Hamster um
 * auf die einzelnen Felder des Spielfelds zu gelangen. Die Werte können für weitere AI-Operationen verwendet werden.
 */
import java.util.ArrayList;

public class HamsterWegfindung {
    Karte karte;
    MeinHamster hamster;

    /**
     * @param hamster - Die Ausgangslage des Hamsters. Dabei ist nur die Position und die Richtung des Hamsters relevant.
     * @param karte - Das Spielfeld. Hier sind alle bisher bekannten Informationen gespeichert.
     */
    public HamsterWegfindung(MeinHamster hamster, Karte karte){
    	this.karte = karte;
    	this.hamster = hamster;
    }

	public int getBestMove(){
		Position position = hamster.getPosition();
		//if(true) {
		//	return Pfad.Calculate(position, karte, 10);
		//}

		int bestDirection = -1;
		double bestChance = -1;
		for(int direction = 0; direction < 4; direction++) {
			Position ziel = position.getPositionInRichtung(direction);
			//Feld f = karte.getFeld(ziel);

			if(karte.getMauer(ziel)==1)
				continue;
			int initialEnergieaufwand;
			initialEnergieaufwand = 2;
			if(position.direction == direction)initialEnergieaufwand=1;
			//double chance = f.getKornChance();
			double chance = berechneKornChancen(ziel, initialEnergieaufwand);

			//double chance = Pfad.Calculate(position, karte, 10);
			if(chance>bestChance || (chance>=bestChance && direction!=position.direction)) { //Bevorzuge abzweigungen.

				bestDirection = direction;
				bestChance = chance;
			}
		}

		Log.write("" + bestDirection + ": " + bestChance);

		return bestDirection;
	}

	/**
	 * Diese Funktion berechnet die Chance auf Körner / den Energieaufwand für Hamster um zu diesem Feld zu gelangen und dies für alle Felder.
	 */
	private double berechneKornChancen(Position fromPosition, int initialEnergieaufwand){
		//Spielfeld-Entfernungen von fromPosition berechnen:
		berechneEntfernungen(fromPosition, initialEnergieaufwand);
		//hamster.schreib(karte.toString());
		double totalChance = 0;
		for(int x=karte.getMinX();x<=karte.getMaxX();x++) {
			for(int y=karte.getMinY();y<=karte.getMaxY();y++){
				Position pos = new Position(x,y,0);
				int energieAufwand = karte.getEnergieAufwand(pos);
				for(int richtung = 1; richtung < 4; richtung++){
					pos.direction = richtung;
					if(karte.getEnergieAufwand(pos)<energieAufwand && karte.getEnergieAufwand(pos)>0)energieAufwand = karte.getEnergieAufwand(pos);
				}
				
				if(energieAufwand > 0)
					totalChance += karte.getKornChance(pos) / new Double(energieAufwand);

				Log.write(""+karte.getKornChance(pos) + " / " + karte.getEnergieAufwand(pos) +" = " +totalChance);

			}
		}
		return totalChance;
	}

	/**
	 * Berechnet die Energieaufwände für den Hamster 'initialHamster' um auf die einzelnen Felder des Spielfelds zu gelangen.
	 */
	private void berechneEntfernungen(Position fromPos, int initialEnergieaufwand){
		doStepfrom(fromPos, initialEnergieaufwand);
	}

	/**
	 * Probiere alle Richtungen durch. Falls ein Feld gefunden wird,
	 * auf dem der hamster noch nicht in entsprechender Richtung war oder hier ein neuer bester Energiewe
	 */
	private void doStepfrom(Position pos, int initialEnergieaufwand){
		ArrayList<Position> steps = new ArrayList<Position>();
		steps.add(pos.clone());
		int maxX=karte.getMaxX();
		int maxY=karte.getMaxY();
		int minX=karte.getMinX();
		int minY=karte.getMinY();

		karte.resetEnergieaufwand();
		karte.setEnergieAufwand(pos, initialEnergieaufwand);

		while(!steps.isEmpty()){
		pos = steps.get(0);
		steps.remove(0);
		//if(	   pos.x <= maxX && pos.y <= maxY
		//	&& pos.x >= minX && pos.y >= minY){
			int momentaneEnergie = karte.getEnergieAufwand(pos);
            for(int direction = 0; direction<4;direction++){
				int benoetigteEnergie;
				benoetigteEnergie = 2;
		    	// Schaut der Hamster schon in entsprechende Richtung,
		    	// braucht er sich nicht mehr drehen
				if(pos.direction == direction)
					benoetigteEnergie = 1;

				Position nextPosition = pos.getPositionInRichtung(direction);
                if(    nextPosition.x <= maxX && nextPosition.y <= maxY
                    && nextPosition.x >= minX && nextPosition.y >= minY){
				if(karte.getMauer(nextPosition)==0){//Es kann nur auf Feldern ohne Mauer gelaufen werden.
					Position drehPosition = nextPosition.clone();
					for(int drehRichtung = 0; drehRichtung < 4; drehRichtung++){
						if(drehRichtung!=pos.direction){
							drehPosition.direction = drehRichtung;
							if(karte.istBessererEnergiewert(drehPosition, momentaneEnergie + benoetigteEnergie + 1)){
								karte.setEnergieAufwand(drehPosition, momentaneEnergie + benoetigteEnergie + 1 );
								steps.add(drehPosition); // nächster Step
							}
						}else{
							if(karte.istBessererEnergiewert(nextPosition, momentaneEnergie + benoetigteEnergie)){
								karte.setEnergieAufwand(nextPosition, momentaneEnergie + benoetigteEnergie);
								steps.add(nextPosition); // nächster Step
							}
						}
					}
				}
			}
		}
		}
	}
}

