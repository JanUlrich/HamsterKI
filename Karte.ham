/*class*/import java.util.HashMap;
/**
 * Die Karte stellt ein Spielfeld mit Variabler Größe dar.
 * Die Felder der Karte können Editiert werden.
 * Quasi die Karte die der Hamster (die AI das Hamsters) dabei hat und alle aufgedeckten Felder darauf vermerkt.
 * Bemerkung:
 * wird auf ein Feld zugegriffen, welches noch nicht erkundet ist, so wird die FeldNichtErkundetException geworfen
 */
public class Karte {
	//private ZweiDimensionalesArray<Feld> karte;
	
	public Karte() {
		//karte = new ZweiDimensionalesArray<Feld>();
	}
	
	
	public int getEnergieAufwand(Position pos) throws FeldNichtErkundetException{
		Feld feld = this.getFeld(pos);
		int ret = feld.getEnergieaufwand(pos.direction);
		return ret;
	}
	
	public void setEnergieAufwand(Position pos, int energieAufwand) throws FeldNichtErkundetException{
		Feld feld = this.getFeld(pos);
		feld.setEnergieaufwand(pos.direction,energieAufwand);
	}
	
	public double getKornChance(Position pos) throws FeldNichtErkundetException{
		return 0;
	}
	
	public void setKornChance(Position pos, Double kornChance) throws FeldNichtErkundetException{
	
	}
	
	public double getMauer(Position pos){
		Feld feld = null;
			feld = this.getFeld(pos);
		return feld.getMauer();
	}
	
	public void setMauer(Position pos, Double mauerWahrscheinlichkeit){

	}
	
	public Position getMaxPosition(){
		return new Position(0,0);
	}
	public Position getMinPosition(){
		return new Position(0,0);
	}
		
	public Feld getFeld(int reihe, int spalte){
		Position pos = new Position(spalte, reihe);
		return getFeld(pos);
	}
	
	/**
	 * Gibt ein Feld mit den bisher auf diesem Feld eingetragenen Informationen zurück.
	 * Dieses kann anschließend editiert werden.
	 * @return - Das Feld an der Stelle reihe,spalte / Wenn kein Feld vorhanden, dann wird FeldNichtErkundetException geworfen.
	 */
	private Feld getFeld(Position pos){
		if(feldBelegt(pos)) {
			int reihe = pos.y;
			int spalte = pos.x;		
			feldZugriff(reihe,spalte);
			String key = generateHashValue(reihe,spalte);
			Feld ret = felder.get(key);
			return ret;
		}
		Feld newFeld = new Feld(0,50); //Hier wird das Standardfeld für unerkundete Felder erstellt. Seine Parameter beeinflussen die Eintscheidungen der KI-Steuerung
		//throw new FeldNichtErkundetException();
		return newFeld;
	}
	
	/**
     * Wichtige Funktion für Wegberechnung.
     * prüft ob der übergebene Energiewert an der übergebenene Position auf dem Spielfeld einen besseren Wert als der bereits vorhandene darstellt.
     * Wichtig: ist das Spielfeld an der Position pos nicht begehbar, wird false zurückgegeben. Nicht begehbare Felder haben keinen Energiewert.
     * Wenn an der übergebenen Position noch kein Energiewert vorhanden ist, dann wird true zurückgegeben.
     */
    public boolean istBessererEnergiewert(Position pos, int energie){
    	Feld feld = this.getFeld(pos);
    	int energieaufwand=feld.getEnergieaufwand(pos.direction);
    	//Hamster.getStandardHamster().schreib("Energie: "+energieaufwand);
    	if(energieaufwand == 0) return true;
    	return energieaufwand>energie;
    }
	
	/**
	 * Baut ein Spielfeld aus den momentan vorhandenen Informationen
	 
	public Spielfeld createSpielfeld(){
		//int height = minReihe;
		//Spielfeld ret = new Spielfeld(width, height);
		ZweiDimensionalesArray<Feld> felder = new ZweiDimensionalesArray<Feld>();
		int minX = karte.getMinSpalte();
		int minY = karte.getMinReihe();
		
		for(int x = minX;x<=karte.getMaxSpalte();x++)for(int y = minY;y<=karte.getMaxReihe();y++){
			Position pos = new Position(x,y);
			Feld feld = this.getFeld(pos);
			if(feld == null){
				feld = new Feld(0.0, 0.25);
			}
			felder.setFeld(new Position(x-minX,y-minY),feld);
		}
		Spielfeld ret = new Spielfeld(felder);
		ret.anfangsSpalte = minX;
		ret.anfangsReihe = minY;
		return ret;
	}
    */
    
    /**
     * Gibt das Feld in der angegebenen Richtung zurück
     * @return Das Feld in der angegebenen Richtung
     
    public Feld getFeldInRichtung(Position position, int richtung) throws FeldNichtErkundetException{
    	int reihe = position.y + (richtung - 1) % 2;
    	int spalte = position.x + (richtung * -1 + 2) % 2;
    	
    	return getFeld(reihe, spalte);
    }
	*/
	
	// Ab hier das ZweidimensionaleArray zur Speicherung der Karte: ================================
	
	private int minReihe = -1;
	private int maxReihe = -1;
	private int minSpalte = -1;
	private int maxSpalte = -1;
	
	private HashMap<String,Feld> felder = new HashMap<String,Feld>();
	
	/**
	 * @return True, falls sich bereits ein Feld an Stelle reihe, spalte befindet - ansonsten false
	 */
	private boolean feldBelegt(Position pos){
		int reihe = pos.y;
		int spalte = pos.x;
		String key = generateHashValue(reihe,spalte);
		return felder.containsKey(key);
	}
	
	public int getMinSpalte(){
		if(minSpalte==-1)return 0;
		return minSpalte;
	}
	
	public int getMaxSpalte(){
		if(maxSpalte==-1)return 0;
		return maxSpalte;
	}
	
	public int getMinReihe(){
		if(minReihe==-1)return 0;
		return minReihe;
	}
	
	public int getMaxReihe(){
		if(maxReihe==-1)return 0;
		return maxReihe;
	}

	private void setFeld(int reihe, int spalte, Feld feld) {
		feldZugriff(reihe, spalte);
		String key = generateHashValue(reihe, spalte);
		felder.put(key, feld);
	}
	
	/**
	 * Bei einem Zugriff auf ein Feld sollte diese Funktion aufgerufen werden.
	 * Wird benötigt um wichtige Variablen für die createSpielfeld-Methode zu setzen.
	 */
	private void feldZugriff(int reihe, int spalte){
		if(reihe<0 || spalte<0)
			throw new IllegalArgumentException("Ungültige Werte für Reihe ("+reihe+") und Spalte ("+spalte+")");
		if(reihe<minReihe || minReihe == -1)
			minReihe=reihe;
		if(reihe>maxReihe || maxReihe == -1)
			maxReihe=reihe;
		if(spalte<minSpalte || minSpalte == -1)
			minSpalte=reihe;
		if(spalte>maxSpalte || maxSpalte == -1)
			maxSpalte=reihe;
	}
	
	private String generateHashValue(int reihe, int spalte){
		return ""+reihe+","+spalte+"";
	}
	
}
