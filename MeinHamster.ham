/*class*/
/**
 * Ein Hamster mit zusätzlichen Funktionalitäten und begrenzter Energie.
 * Verbraucht für jede Drehung und jede Bewegung auf eine andere Kachel Energie.
 * Kann sich nur so lange bewegen, wie Energie vorhanden.
 */
public class MeinHamster extends Hamster {
    private Position startPosition;
	private Position position;
	private Karte karte;
	private int energieLevel;

    public MeinHamster(int y, int x, int blickrichtung, int koerner){
    	super(y,x,blickrichtung,koerner);
    	energieLevel = Territorium.getAnzahlSpalten() * Territorium.getAnzahlReihen() * 5;;
   		karte = new Karte();
   		position = new Position(0,0,getDirection());
        startPosition = new Position(getSpalte(), getReihe(), getBlickrichtung());
    }

	/**
	 * Dreht den Hamster in die übergebene Richtung. Dabei wird Energie verbraucht.
	 * @param Richtung - Zahl 0-3, steht für die 4 Himmelsrichtungen.
	 * Sind die Parameter ungültig oder schaut der Hamster bereits
	 * in die gewünschte Richtung wird keine Energie verbraucht und
	 * keine Drehung ausgeführt.
	 */
	public MeinHamster dreheInRichtung(int Richtung) throws HamsterEnergieException {
		if(Richtung>3 || Richtung < 0 || getBlickrichtung() == Richtung)
			return this;

		while(getBlickrichtung()!=Richtung)
			linksUm();

		verbraucheEnergie();
		return this;
	}

	/**
     * @author Simon Herrmann
     * @param karte Karte des Hamsters
     * @return Karte des Hamsters mit nach der Sensorabfrage
     */
    void KachelnAbfragen() {
    	Position hamsterPos = getPosition();

    	for (int i = hamsterPos.y-1; i <= hamsterPos.y+1; i++) {
    		for (int j = hamsterPos.x-1; j <= hamsterPos.x+1; j++) {

		    	//Feld f = karte.getFeld(i,j);
    			if (mauerDa(i,j))
    				karte.setMauer(new Position(j,i), 1.0);
    			else
    				karte.setMauer(new Position(j,i), 0.0);
    			//karte.setFeld(i,j,f);

    		}
    	}

		if(!kornDa()) {
			//karte.getFeld(y, x).setKoerner(0);
			karte.setKornChance(hamsterPos, 0.0);
        }
    }

    private boolean mauerDa(int y, int x){
    	y += startPosition.y;
    	x += startPosition.x;
    	return Territorium.mauerDa(y, x);
    }

    public void forward() throws HamsterEnergieException {
        super.vor();
        //TODO Position aktualisieren
        verbraucheEnergie();
    }

    @Override
    public void vor() {
        //ERROR
    }

	private void verbraucheEnergie() throws HamsterEnergieException
	{
		if(energieLevel==0)
			throw new HamsterEnergieException();
		energieLevel--;
	}

    public Position getPosition(){
    	return position;
    }

    /**
     * Bewegt den Hamster KI gesteuert einen Schritt weiter
     */
    public void kiStep() throws HamsterEnergieException {
    	// Als erstes Umgebung abfragen
    	KachelnAbfragen();

    	int richtung = berechneZug();
    	dreheInRichtung(richtung);
    	forward();
    	if(kornDa())
    		nimm();
    }

    /**
     * @return - gibt die Richtung zurück
     */
    private int berechneZug() {
    	//Spielfeld sp = karte.createSpielfeld();
    	HamsterWegfindung ki = new HamsterWegfindung(this, karte);
    	//ki.berechneEntfernungen();

    	//int richtung = getBlickrichtung();
		//while(!freiInRichtung(richtung)) {
		//	richtung = (richtung + 1) % 4;
		//}
		return ki.getBestMove();
    }

    /**
     * Gibt zurück, ob in der angegebenen Richtung frei ist,
     * oder ob dort eine Mauer liegt
     * @return true, wenn in der angegebenen Richtung keine Mauer ist
     */
    private boolean freiInRichtung(int richtung) {
    	Feld feld = feldInRichtung(richtung);
    	return feld.getMauer() < 1;
    }

    /**
     * Gibt das Feld in der angegebenen Richtung zurück
     * @return Das Feld in der angegebenen Richtung
     */
    private Feld feldInRichtung(int richtung) {
    	return karte.getFeldInRichtung(getPosition(), richtung);
    }
}
