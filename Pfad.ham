/*class*/
import java.util.Stack;
import java.util.Arrays;
class Pfad {
	Karte karte;
	Stack<Integer> richtungen;
	Position start;

	/**
	 * Erstellt einen neuen Pfad
	 * @param karte Die Karte die zur Validierung verwendet werden soll
	 * @param start Der Startpunkt des Pfades
	 */
	public Pfad(Karte karte, Position start) {
		richtungen = new Stack<Integer>();
		this.karte = karte;
		this.start = start;
	}

	/**
	 * @return Gibt eine Kopie des aktuellen Pfades zurück
	 */
	public Pfad clone() {
		Pfad newPfad = new Pfad(karte, start);
		newPfad.richtungen = (Stack)richtungen.clone();
		return newPfad;
	}

	/**
	 * @return true if Path contains no more directions
	 */
	public boolean isEmpty() {
		return richtungen.isEmpty();
	}

	/**
	 * @return Die Anzahl der im Pfad gespeicherten Schritte
	 */
	public int length() {
		return richtungen.size();
	}

	/**
	 * Adds the specified direction to the Path
	 * @param richtung the direction to be added
	 */
	public void addStep(int richtung) {
		richtungen.push(new Integer(richtung));
	}

	/**
	 * Calculates the Corn/Energy ratio
	 * @return the path's Corn/Energy ratio
	 */
	public double getRatio() {
		Stack tempRichtungen = (Stack)richtungen.clone();

		Position pos = start;
		double energie = 0;
		double kornChance = 0;

		while(!tempRichtungen.isEmpty()) {
			Integer richtung = (Integer)tempRichtungen.pop();
			pos = pos.getPositionInRichtung(richtung);

			if(richtung!=pos.direction)
				energie++;		// Drehung, wenn nötig
			energie++;			// Schritt vorwärts

			kornChance += karte.getKornChance(pos);
			if(karte.getMauer(pos)==1) {
				return -999;
			}
		}

		return (double)kornChance/energie;
	}

	/**
	 * Calculates the Corn/Energy ratio
	 * @return the path's Corn/Energy ratio
	 */
	public double getKornChance() {
		Stack tempRichtungen = (Stack)richtungen.clone();

		Position pos = start;
		double kornChance = 0;

		while(!tempRichtungen.isEmpty()) {
			Integer richtung = (Integer)tempRichtungen.pop();
			pos = pos.getPositionInRichtung(richtung);

			kornChance += karte.getKornChance(pos);
			if(karte.getMauer(pos)==1) {
				return -999;
			}
		}

		return (double)kornChance;
	}

	/**
	 * Calculates the energy Consumption for the current path
	 * @return the path's total energy consumption
	 */
	public int getEnergie() {
		Stack tempRichtungen = (Stack)richtungen.clone();
		int energie = 0;
		int lastDirection = start.direction;

		while(!tempRichtungen.isEmpty()) {
			Integer richtung = (Integer)tempRichtungen.pop();

			if(richtung!=lastDirection)
				energie++;		// Drehung, wenn nötig
			energie++;			// Schritt vorwärts
			lastDirection = richtung;
		}
		return energie;
	}

	/**
	 * @return true, if the current Path does not collide
	 */
	public boolean isValid() {
		return isValid(false);
	}

	/**
	 * @param print Pass true, if debug output should be shown
	 * @return true, if the current Path does not collide
	 */
	public boolean isValid(boolean print) {
		Stack tempRichtungen = (Stack)richtungen.clone();
		Position pos = start;
		String x = "";
		while(!tempRichtungen.isEmpty()) {
			Integer richtung = (Integer)tempRichtungen.pop();
			pos = pos.getPositionInRichtung(richtung);
			x += "" + pos.x + ", " + pos.y + "   " + karte.getMauer(pos) + "\n";
			if(karte.getMauer(pos)==1) {
				return false;
			}
		}
		if(print)
			Log.write(x);
		return true;
	}

	/**
	 * @return the next path's next direction
	 */
	public int getNextRichtung() {
		int richtung = (Integer)richtungen.pop();
		start = start.getPositionInRichtung(richtung);
		return richtung;
	}

	@Override
	public String toString() {
		return Arrays.toString(richtungen.toArray());
	}
}
