/*class*/import java.util.*;

class Pfad {
	Karte karte;
	Stack<Integer> richtungen;
	Position start;

	public Pfad(Karte karte, Position start) {
		richtungen = new Stack<Integer>();
		this.karte = karte;
		this.start = start;
	}

	public Pfad(Karte karte, Position start, int[] directions) {
		this(karte, start);
		for(int i=directions.length-1; i>=0; i--) {
			addStep(directions[i]);
		}
	}

	public void addStep(int richtung) {
		richtungen.push(new Integer(richtung));
	}

	public double getRatio() {
		Stack tempRichtungen = (Stack)richtungen.clone();

		Position pos = start;
		int energie = 0;
		double kornChance = 0;

		while(!tempRichtungen.isEmpty()) {
			Integer richtung = (Integer)tempRichtungen.pop();
			pos = getPositionInRichtung(pos, richtung);

			if(richtung!=pos.direction)
				energie++;		// Drehung, wenn nötig
			energie++;			// Schritt vorwärts

			kornChance += karte.getKornChance(pos);
			if(karte.getMauer(pos)==1) {
				return -999;
			}
		}

		return (double)kornChance/energie;
	}

	public boolean isValid() {
		Stack tempRichtungen = (Stack)richtungen.clone();
		Position pos = start;
		while(!tempRichtungen.isEmpty()) {
			Integer richtung = (Integer)tempRichtungen.pop();
			pos = getPositionInRichtung(pos, richtung);
			if(karte.getMauer(pos)==1) {
				return false;
			}
		}
		return true;
	}

	public int getNextRichtung() {
		return (Integer)richtungen.peek();
	}

	public Position getPositionInRichtung(Position start, int richtung) {
		switch(richtung) {
			case 0:
				return new Position(start.x, start.y-1);
			case 1:
				return new Position(start.x+1, start.y);
			case 2:
				return new Position(start.x, start.y+1);
			case 3:
				return new Position(start.x-1, start.y);
			default:
				throw new IllegalArgumentException("Ungültige Richtungsangabe");
		}
	}

	public static int Calculate(Position start, Karte karte, int maxSteps) {
		double bestRatio = -1;
		Pfad bestPath = null;

		int[] directions = new int[maxSteps];
		for(int i=0; i<maxSteps; i++) directions[i] = 0;

		int z = 0;
		while(directions[0]!=4) {
			Pfad p = new Pfad(karte, start, directions);
			double ratio = p.getRatio();

			if(ratio>bestRatio && p.isValid()) {
				//Log.write("" + ++z + Arrays.toString(directions) + ": " + ratio);
				bestRatio = ratio;
				bestPath = p;
			}

			directions[maxSteps-1]++;
			for(int i = maxSteps-1; i>0; i--) {
				if(directions[i]==4) {
					directions[i]=0;
					directions[i-1]++;
				}
			}
		}
		return bestPath.getNextRichtung();
	}
}
