/*class*/
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;
import java.util.Collections;
class PfadWegfindung extends Wegfindung {
	public static int maxSteps = 1;
	private Pfad bestPath = null;

	public List<Pfad> x(Position start, Pfad pfad) {
		if(pfad==null) {
			pfad = new Pfad(karte, start);
		}

		List<Pfad> pfade = new ArrayList<Pfad>();

		if(pfad.length()==maxSteps) {
			pfade.add(pfad);
			return pfade;
		}

		for(int r=0; r<4; r++) {
			Position nextPos = start.getPositionInRichtung(r);
			if(karte.getMauer(nextPos)==1)
				continue;
			Pfad p = pfad.clone();
			p.addStep(r);
			pfade.addAll(x(nextPos, p));
		}


		return pfade;
	}





	public int getBestMove(){
		double kornChance = -1;
		if(	bestPath==null ||
			bestPath.isEmpty() ||
			!bestPath.isValid() ||
			(maxSteps<3 &&bestPath.length()<maxSteps) ||
			bestPath.length()<maxSteps/2) {
			do {
				bestPath = null;
				Position start = hamster.getPosition();
				int bestEnergie = 99999;

				int[] directions = new int[maxSteps];
				while(directions[0]!=4) {
					Pfad p = new Pfad(karte, start, directions);

					double ratio = p.getKornChance();
					int energie = p.getEnergie();
					if(p.isValid() && (ratio>kornChance || (ratio>=kornChance && energie<bestEnergie))) {
						Log.write(Arrays.toString(directions) + ": " + ratio);
						kornChance = ratio;
						bestPath = p;
						bestEnergie = energie;
					}

					directions = nextCombination(directions);
				}
				if(kornChance>0) break;
					maxSteps++;

				String debug = karte.toString(start);
				debug += "\n\n" + bestPath.toString();
				debug += "\n\n" + maxSteps;
				debug += "\n\n" + bestEnergie + "\n" + kornChance;
				hamster.schreib("Vorausschau um ein Feld erh√∂ht\n" + debug);

			} while(kornChance <=0);
		}

		//hamster.schreib("" + bestPath.length() + "\n" + bestPath.isEmpty() + bestPath.isValid(true));
		return bestPath.getNextRichtung();
	}

	private int[] nextCombination(int[] directions) {
		directions[maxSteps-1]++;
		for(int i = maxSteps-1; i>0; i--) {
			if(directions[i]==4) {
				directions[i]=0;
				directions[i-1]++;
			}
		}
		return directions;
	}
}